/*!
* rete-minimap-plugin v0.3.1 
* (c) 2019 Vitaliy Stoliarov 
* Released under the MIT license.
*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Vue = _interopDefault(require('vue'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function drag(el) {
  var getInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
  var onDrag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
  var start = null;
  var initial = null;
  el.addEventListener('mousedown', function (e) {
    initial = getInitial();
    start = [e.pageX, e.pageY];
  });
  window.addEventListener('mousemove', function (e) {
    if (!start) return;
    var dx = start[0] - e.pageX,
        dy = start[1] - e.pageY;
    onDrag(dx, dy, initial);
  });
  window.addEventListener('mouseup', function () {
    start = null;
  });
}

function nodesBBox(nodes) {
  var nv = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
  var lefts = nodes.map(function (n) {
    return n.position[0];
  });
  var rights = nodes.map(function (n) {
    return n.position[0] + nv(n).clientWidth;
  });
  var tops = nodes.map(function (n) {
    return n.position[1];
  });
  var bottoms = nodes.map(function (n) {
    return n.position[1] + nv(n).clientHeight;
  });
  var left = Math.min.apply(Math, _toConsumableArray(lefts)),
      right = Math.max.apply(Math, _toConsumableArray(rights)),
      top = Math.min.apply(Math, _toConsumableArray(tops)),
      bottom = Math.max.apply(Math, _toConsumableArray(bottoms));
  return {
    left: left,
    right: right,
    top: top,
    bottom: bottom,
    width: right - left,
    height: bottom - top
  };
}

var script = {
  props: ['size', 'nodes', 'views', 'view'],
  data: function data() {
    return {
      transform: {
        ox: 0,
        oy: 0,
        scale: function scale() {
          return 1;
        },
        invert: function invert() {
          return 1;
        }
      }
    };
  },
  mounted: function mounted() {
    var _this = this;

    drag(this.$refs.viewport, function () {
      return _objectSpread({}, _this.view.area.transform);
    }, function (dx, dy, initial) {
      var x = initial.x,
          y = initial.y,
          k = initial.k;
      var invert = _this.transform.invert;

      _this.view.area.translate(x + k * invert(dx), y + k * invert(dy));
    });
    this.updateTransform();
  },
  watch: {
    size: function size() {
      this.updateTransform();
    }
  },
  methods: {
    mapClass: function mapClass() {
      return _defineProperty({}, this.size, true);
    },
    updateTransform: function updateTransform() {
      var _nodesBBox = nodesBBox(this.nodes, this.nv),
          left = _nodesBBox.left,
          top = _nodesBBox.top,
          width = _nodesBBox.width,
          height = _nodesBBox.height;

      var space = Math.max(2000, Math.max(width, height));
      var w = this.$refs.area.clientWidth;
      var h = this.$refs.area.clientHeight;
      var ox = (space - width) / 2 - left;
      var oy = (space * h / w - height) / 2 - top;
      this.transform = {
        scale: function scale(v) {
          return v * (w / space);
        },
        invert: function invert(v) {
          return v / (w / space);
        },
        ox: ox,
        oy: oy
      };
    },
    px: function px(v) {
      return v + 'px';
    },
    nv: function nv(node) {
      return this.views.get(node).el;
    },
    nodeStyle: function nodeStyle(node) {
      var _this$transform = this.transform,
          ox = _this$transform.ox,
          oy = _this$transform.oy,
          scale = _this$transform.scale;
      return {
        left: this.px(scale(ox + node.position[0])),
        top: this.px(scale(oy + node.position[1])),
        width: this.px(scale(this.nv(node).clientWidth)),
        height: this.px(scale(this.nv(node).clientHeight))
      };
    },
    viewportStyle: function viewportStyle() {
      var _this$transform2 = this.transform,
          ox = _this$transform2.ox,
          oy = _this$transform2.oy,
          scale = _this$transform2.scale;
      var _this$view$area$trans = this.view.area.transform,
          x = _this$view$area$trans.x,
          y = _this$view$area$trans.y,
          k = _this$view$area$trans.k;
      var width = this.view.container.clientWidth;
      var height = this.view.container.clientHeight;
      return {
        left: this.px(scale(ox - x / k)),
        top: this.px(scale(oy - y / k)),
        width: this.px(scale(width / k)),
        height: this.px(scale(height / k))
      };
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
function createInjector(context) {
  return function (id, style) {
    return addStyle(id, style);
  };
}
var HEAD;
var styles = {};

function addStyle(id, css) {
  var group = isOldIE ? css.media || 'default' : id;
  var style = styles[group] || (styles[group] = {
    ids: new Set(),
    styles: []
  });

  if (!style.ids.has(id)) {
    style.ids.add(id);
    var code = css.source;

    if (css.map) {
      // https://developer.chrome.com/devtools/docs/javascript-debugging
      // this makes source maps inside style tags work properly in Chrome
      code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

      code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
    }

    if (!style.element) {
      style.element = document.createElement('style');
      style.element.type = 'text/css';
      if (css.media) style.element.setAttribute('media', css.media);

      if (HEAD === undefined) {
        HEAD = document.head || document.getElementsByTagName('head')[0];
      }

      HEAD.appendChild(style.element);
    }

    if ('styleSheet' in style.element) {
      style.styles.push(code);
      style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
    } else {
      var index = style.ids.size - 1;
      var textNode = document.createTextNode(code);
      var nodes = style.element.childNodes;
      if (nodes[index]) style.element.removeChild(nodes[index]);
      if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
    }
  }
}

var browser = createInjector;

/* script */
const __vue_script__ = script;

/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "minimap", class: _vm.mapClass() }, [
    _c(
      "div",
      {
        ref: "area",
        staticClass: "area",
        on: {
          mousedown: function($event) {
            $event.stopPropagation();
            $event.preventDefault();
          }
        }
      },
      [
        _vm._l(_vm.nodes, function(node) {
          return _c("div", {
            staticClass: "mini-node",
            style: _vm.nodeStyle(node)
          })
        }),
        _c("div", {
          ref: "viewport",
          staticClass: "mini-viewport",
          style: _vm.viewportStyle()
        })
      ],
      2
    )
  ])
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  const __vue_inject_styles__ = function (inject) {
    if (!inject) return
    inject("data-v-775d45b0_0", { source: ".minimap[data-v-775d45b0] {\n  position: absolute;\n  right: 24px;\n  bottom: 24px;\n  background: rgba(89, 132, 152, 0.1);\n  padding: 20px;\n  overflow: hidden;\n  border: 1px solid #b1b7ff;\n  border-radius: 8px;\n}\n.minimap.small[data-v-775d45b0] {\n  width: 150px;\n  height: 150px;\n}\n.minimap[data-v-775d45b0], .minimap.middle[data-v-775d45b0] {\n  width: 220px;\n  height: 220px;\n}\n.minimap.large[data-v-775d45b0] {\n  width: 300px;\n  height: 300px;\n}\n.minimap .area[data-v-775d45b0] {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.minimap .mini-node[data-v-775d45b0] {\n  position: absolute;\n  background: rgba(110, 136, 255, 0.8);\n}\n.minimap .mini-viewport[data-v-775d45b0] {\n  position: absolute;\n  background: rgba(255, 251, 128, 0.32);\n  border: 1px solid #ffe52b;\n}\n\n/*# sourceMappingURL=Map.vue.map */", map: {"version":3,"sources":["/home/travis/build/retejs/minimap-plugin/src/Map.vue","Map.vue"],"names":[],"mappings":"AA4FA;EACA,kBAAA;EACA,WAAA;EACA,YAAA;EACA,mCAAA;EACA,aAAA;EACA,gBAAA;EACA,yBAAA;EACA,kBAAA;AC3FA;AD4FA;EACA,YAAA;EACA,aAAA;AC1FA;AD2FA;EACA,YAAA;EACA,aAAA;ACzFA;AD0FA;EACA,YAAA;EACA,aAAA;ACxFA;ADyFA;EACA,kBAAA;EACA,WAAA;EACA,YAAA;ACvFA;ADwFA;EACA,kBAAA;EACA,oCAAA;ACtFA;ADuFA;EACA,kBAAA;EACA,qCAAA;EACA,yBAAA;ACrFA;;AAEA,kCAAkC","file":"Map.vue","sourcesContent":["<template lang=\"pug\">\n.minimap(:class=\"mapClass()\")\n    .area(ref=\"area\", @mousedown.stop.prevent=\"\")\n        .mini-node(\n            v-for=\"node in nodes\"\n            :style=\"nodeStyle(node)\"\n        )\n        .mini-viewport(ref=\"viewport\"\n            :style=\"viewportStyle()\"\n        )\n</template>\n\n<script>\nimport { drag } from './drag';\nimport { nodesBBox } from './utils';\n\nexport default {\n    props: ['size', 'nodes', 'views', 'view'],\n    data() {\n        return {\n            transform: { ox: 0, oy: 0, scale: () => 1, invert: () => 1 }\n        }\n    },\n    mounted() {\n        drag(this.$refs.viewport, () => {\n            return { ...this.view.area.transform }\n        }, (dx, dy, initial) => {\n            let { x, y, k } = initial;\n            let { invert } = this.transform;\n    \n            this.view.area.translate(x + k * invert(dx), y + k * invert(dy));\n        });\n        this.updateTransform();\n    },\n    watch: {\n        size() { this.updateTransform() }\n    },\n    methods: {\n        mapClass() {\n            return {\n                [this.size]: true\n            }\n        },\n        updateTransform() {\n            let { left, top, width, height } = nodesBBox(this.nodes, this.nv);\n            let space = Math.max(2000, Math.max(width, height));\n            let w = this.$refs.area.clientWidth;\n            let h = this.$refs.area.clientHeight;\n            let ox = (space - width) / 2 - left;\n            let oy = (space * h / w - height) / 2 - top;\n\n            this.transform = {\n                scale: v => v * (w / space),\n                invert: v => v / (w / space),\n                ox, \n                oy\n            }\n        },\n        px(v) {\n            return v+'px';\n        },\n        nv(node) {\n            return this.views.get(node).el;\n        },\n        nodeStyle(node) {\n            let { ox, oy, scale } = this.transform;\n\n            return {\n                left: this.px(scale(ox + node.position[0])), \n                top: this.px(scale(oy + node.position[1])), \n                width: this.px(scale(this.nv(node).clientWidth)), \n                height: this.px(scale(this.nv(node).clientHeight))\n            }\n        },\n        viewportStyle() {\n            let { ox, oy, scale } = this.transform;\n            let { x, y, k } = this.view.area.transform;\n            let width = this.view.container.clientWidth;\n            let height = this.view.container.clientHeight;\n            \n            return {\n                left: this.px(scale(ox - x / k)), \n                top: this.px(scale(oy - y / k)), \n                width: this.px(scale(width / k)), \n                height: this.px(scale(height / k))\n            }\n        }\n    }\n}\n</script>\n\n<style lang=\"sass\" scoped>\n.minimap\n    position: absolute\n    right: 24px\n    bottom: 24px\n    background: rgba(89, 132, 152, 0.1)\n    padding: 20px\n    overflow: hidden\n    border: 1px solid #b1b7ff\n    border-radius: 8px\n    &.small\n        width: 150px\n        height: 150px\n    &, &.middle\n        width: 220px\n        height: 220px\n    &.large\n        width: 300px\n        height: 300px\n    .area\n        position: relative\n        width: 100%\n        height: 100%\n    .mini-node\n        position: absolute\n        background: rgba(110, 136, 255, 0.8)\n    .mini-viewport\n        position: absolute\n        background: rgba(255, 251, 128, 0.32)\n        border: 1px solid #ffe52b\n</style>",".minimap {\n  position: absolute;\n  right: 24px;\n  bottom: 24px;\n  background: rgba(89, 132, 152, 0.1);\n  padding: 20px;\n  overflow: hidden;\n  border: 1px solid #b1b7ff;\n  border-radius: 8px;\n}\n.minimap.small {\n  width: 150px;\n  height: 150px;\n}\n.minimap, .minimap.middle {\n  width: 220px;\n  height: 220px;\n}\n.minimap.large {\n  width: 300px;\n  height: 300px;\n}\n.minimap .area {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.minimap .mini-node {\n  position: absolute;\n  background: rgba(110, 136, 255, 0.8);\n}\n.minimap .mini-viewport {\n  position: absolute;\n  background: rgba(255, 251, 128, 0.32);\n  border: 1px solid #ffe52b;\n}\n\n/*# sourceMappingURL=Map.vue.map */"]}, media: undefined });

  };
  /* scoped */
  const __vue_scope_id__ = "data-v-775d45b0";
  /* module identifier */
  const __vue_module_identifier__ = undefined;
  /* functional template */
  const __vue_is_functional_template__ = false;
  /* style inject SSR */
  

  
  var Map = normalizeComponent_1(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    browser,
    undefined
  );

var SIZE = {
  SMALL: 'small',
  MIDDLE: 'middle',
  LARGE: 'large'
};

function install(editor, params) {
  Vue.observable(params);
  params.enable = params.enable !== false;
  params.size = params.size || SIZE.MIDDLE;
  var el = document.createElement('div');
  editor.view.container.appendChild(el);
  var app = new Vue({
    render: function render(h) {
      return params.enable ? h(Map, {
        props: {
          size: params.size,
          nodes: editor.nodes,
          views: editor.view.nodes,
          view: editor.view
        }
      }) : null;
    }
  }).$mount(el);

  var updateTransform = function updateTransform() {
    return app.$children[0] && app.$children[0].updateTransform();
  };

  editor.on('nodetranslated nodecreated noderemoved translated zoomed', updateTransform);
  window.addEventListener('resize', updateTransform);
  editor.on('destroy', function () {
    window.removeEventListener('resize', updateTransform);
  });
}

var index = _objectSpread({
  install: install
}, SIZE);

exports.default = index;
//# sourceMappingURL=minimap-plugin.common.js.map
