{"version":3,"file":"app.min.js","sources":["../node_modules/stage0/index.js","../node_modules/stage0/keyed.js","../node_modules/stage0/reconcile.js","../app.js"],"sourcesContent":["\nconst nativeToSyntheticEvent = (event, name) => {\n    const eventKey = `__${name}`\n    let dom = event.target\n    while(dom !== null) {\n        const eventHandler = dom[eventKey]\n        if (eventHandler) {\n            eventHandler()\n            return\n        }\n        dom = dom.parentNode\n    }\n}\nconst CONFIGURED_SYNTHETIC_EVENTS = {}\nexport function setupSyntheticEvent(name) {\n    if (CONFIGURED_SYNTHETIC_EVENTS[name]) return\n    document.addEventListener(name, event => nativeToSyntheticEvent(event, name))\n    CONFIGURED_SYNTHETIC_EVENTS[name] = true\n}\n\nfunction collector(node) {\n  if (node.nodeType !== 3) {\n    if (node.attributes !== undefined) {\n      for(let attr of node.attributes) {\n        let aname = attr.name\n        if (aname[0] === '#') {\n          node.removeAttribute(aname)\n          return aname.slice(1)\n        }\n      }\n    }\n    return 0\n  } else {\n    let nodeData = node.nodeValue\n    if (nodeData[0] === '#') {\n      node.nodeValue = \"\"\n      return nodeData.slice(1)\n    }\n    return 0\n  }\n}\n\nfunction walker(node) {\n  let skip = false, tmp, pathId = '', prevPathId, pahtIdLen, code1, code2, ref\n  code1 = code2 = ''\n  if (ref = collector(node)) code2 += `refs.${ref} = node;\\n` \n  do {\n      if (!skip && (tmp = node.firstChild)) {\n          skip = false       \n\n          prevPathId = pathId\n          pathId += '_f'\n          code1 += `let ${pathId} = ${prevPathId || 'node'}.firstChild;\\n` \n\n          if (ref = collector(tmp)) code2 += `refs.${ref} = ${pathId};\\n` \n      } else if (tmp = node.nextSibling) {\n          skip = false\n\n          prevPathId = pathId\n          pathId += '_n'\n          code1 += `let ${pathId} = ${prevPathId || 'node'}.nextSibling;\\n` \n\n          if (ref = collector(tmp)) code2 += `refs.${ref} = ${pathId};\\n` \n      } else {\n          pahtIdLen = pathId.length\n          if (pathId[pahtIdLen - 1] === 'n') {\n              pathId = pathId.slice(0, pathId.lastIndexOf('_f_n'))\n          } else {\n             pathId = pathId.slice(0, pahtIdLen- 2) \n          }\n          tmp = node.parentNode\n          skip = true\n      }\n      node = tmp\n  } while (node)\n  return Function('node', code1 + 'let refs = {};\\n' + code2 + 'return refs;\\n')\n}\n\nconst compilerTemplate = document.createElement('template')\nexport function h(strings) {\n  const template = strings[0].replace(/\\n*/g, '').replace(/\\s*</g, '<').replace(/>\\s*/g, '>')\n  compilerTemplate.innerHTML = template\n  const content = compilerTemplate.content.firstChild\n  content.collect = walker(content)\n  return content\n}\nexport default h\n","\n// This is almost straightforward implementation of reconcillation algorithm\n// based on ivi documentation:\n// https://github.com/localvoid/ivi/blob/2c81ead934b9128e092cc2a5ef2d3cabc73cb5dd/packages/ivi/src/vdom/implementation.ts#L1366\n// With some fast paths from Surplus implementation:\n// https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L86\n//\n// How this implementation differs from others, is that it's working with data directly,\n// without maintaining nodes arrays, and uses dom props firstChild/lastChild/nextSibling\n// for markers moving.\nexport function keyed(key, parent, renderedValues, data, createFn, noOp, beforeNode) {\n    // Fast path for clear\n    if (data.length === 0) {\n        parent.textContent = \"\"\n        return\n    }\n\n    // Fast path for create\n    if (renderedValues.length === 0) {\n        let node\n        for(let i = 0, len = data.length; i < len; i++) {\n            node = createFn(data[i])\n            parent.appendChild(node)\n        }\n        return\n    }\n\n    let prevStart = 0,\n        newStart = 0,\n        loop = true,\n        prevEnd = renderedValues.length-1, newEnd = data.length-1,\n        a, b,\n        prevStartNode = beforeNode ? beforeNode.nextSibling : parent.firstChild,\n        newStartNode = prevStartNode,\n        prevEndNode = parent.lastChild,\n        newEndNode = prevEndNode,\n        afterNode\n    \n    fixes: while(loop) {\n        loop = false\n        let _node\n\n        // Skip prefix\n        a = renderedValues[prevStart], b = data[newStart]\n        while(a[key] === b[key]) {\n            noOp(prevStartNode, b)\n            prevStart++\n            newStart++\n            newStartNode = prevStartNode = prevStartNode.nextSibling\n            if (prevEnd < prevStart || newEnd < newStart) break fixes\n            a = renderedValues[prevStart]\n            b = data[newStart]\n        }\n\n        // Skip suffix\n        a = renderedValues[prevEnd], b = data[newEnd]\n        while(a[key] === b[key]) {\n            noOp(prevEndNode, b)\n            prevEnd--\n            newEnd--\n            afterNode = prevEndNode\n            newEndNode = prevEndNode = prevEndNode.previousSibling\n            if (prevEnd < prevStart || newEnd < newStart) break fixes\n            a = renderedValues[prevEnd]\n            b = data[newEnd]\n        }\n\n        // Fast path to swap backward\n        a = renderedValues[prevEnd], b = data[newStart]\n        while(a[key] === b[key]) {\n            loop = true\n            noOp(prevEndNode, b)\n            _node = prevEndNode.previousSibling\n            parent.insertBefore(prevEndNode, newStartNode)\n            newEndNode = prevEndNode = _node\n            newStart++\n            prevEnd--\n            if (prevEnd < prevStart || newEnd < newStart) break fixes\n            a = renderedValues[prevEnd]\n            b = data[newStart]\n        }\n\n        // Fast path to swap forward\n        a = renderedValues[prevStart], b = data[newEnd]\n        while(a[key] === b[key]) {\n            loop = true\n            noOp(prevStartNode, b)\n            _node = prevStartNode.nextSibling\n            parent.insertBefore(prevStartNode, afterNode)\n            prevStart++\n            afterNode = newEndNode = prevStartNode\n            prevStartNode = _node\n            newEnd--\n            if (prevEnd < prevStart || newEnd < newStart) break fixes\n            a = renderedValues[prevStart]\n            b = data[newEnd]\n        }\n    }\n\n    // Fast path for shrink\n    if (newEnd < newStart) {\n        if (prevStart <= prevEnd) {\n            let next\n            while(prevStart <= prevEnd) {\n                if (prevEnd === 0) {\n                    parent.removeChild(prevEndNode)\n                } else {\n                    next = prevEndNode.previousSibling    \n                    parent.removeChild(prevEndNode)\n                    prevEndNode = next\n                }\n                prevEnd--\n            }\n        }\n        return\n    }\n\n    // Fast path for add\n    if (prevEnd < prevStart) {\n        if (newStart <= newEnd) {\n            let node, mode = afterNode ? 1 : 0\n            while(newStart <= newEnd) {\n                node = createFn(data[newStart])\n                mode ? parent.insertBefore(node, afterNode) : parent.appendChild(node)\n                newStart++\n            }\n        }\n        return\n    }\n\n    // Positions for reusing nodes from current DOM state\n    const P = new Array(newEnd + 1 - newStart)\n    for(let i = newStart; i <= newEnd; i++) P[i] = -1\n\n    // Index to resolve position from current to new\n    const I = new Map()\n    for(let i = newStart; i <= newEnd; i++) I.set(data[i][key], i)\n\n    let reusingNodes = 0, toRemove = []\n    for(let i = prevStart; i <= prevEnd; i++) {\n        if (I.has(renderedValues[i][key])) {\n            P[I.get(renderedValues[i][key])] = i\n            reusingNodes++\n        } else {\n            toRemove.push(i)\n        }\n    }\n\n    // Fast path for full replace\n    if (reusingNodes === 0) {\n        if (beforeNode) {\n            let node = beforeNode.nextSibling, tmp\n            while(prevStart <= prevEnd) {\n                tmp = node.nextSibling\n                parent.removeChild(node)\n                node = tmp\n                prevStart++\n            }\n        } else {\n            parent.textContent = \"\"\n        }\n        let node\n        for(let i = newStart; i <= newEnd; i++) {\n            node = createFn(data[i])\n            parent.appendChild(node)\n        }\n\n        return\n    }\n\n    // What else?\n    const longestSeq = longestPositiveIncreasingSubsequence(P, newStart)\n\n    // Collect nodes to work with them\n    const nodes = []\n    let tmpC = prevStartNode\n    for(let i = prevStart; i <= prevEnd; i++) {\n        nodes[i] = tmpC\n        tmpC = tmpC.nextSibling\n    }\n\n    for(let i = 0; i < toRemove.length; i++) parent.removeChild(nodes[toRemove[i]])\n\n    let lisIdx = longestSeq.length - 1, tmpD\n    for(let i = newEnd; i >= newStart; i--) {\n        if(longestSeq[lisIdx] === i) {\n            afterNode = nodes[P[longestSeq[lisIdx]]]\n            noOp(afterNode, data[i])\n            lisIdx--\n        } else {\n            if (P[i] === -1) {\n                tmpD = createFn(data[i])\n            } else {\n                tmpD = nodes[P[i]]\n                noOp(tmpD, data[i])\n            }\n            parent.insertBefore(tmpD, afterNode)\n            afterNode = tmpD\n        }\n    }\n}\n\nexport default keyed\n\n// Picked from\n// https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L368\n\n// return an array of the indices of ns that comprise the longest increasing subsequence within ns\nfunction longestPositiveIncreasingSubsequence(ns, newStart) {\n    var seq = [],\n        is  = [],\n        l   = -1,\n        pre = new Array(ns.length);\n\n    for (var i = newStart, len = ns.length; i < len; i++) {\n        var n = ns[i];\n        if (n < 0) continue;\n        var j = findGreatestIndexLEQ(seq, n);\n        if (j !== -1) pre[i] = is[j];\n        if (j === l) {\n            l++;\n            seq[l] = n;\n            is[l]  = i;\n        } else if (n < seq[j + 1]) {\n            seq[j + 1] = n;\n            is[j + 1] = i;\n        }\n    }\n\n    for (i = is[l]; l >= 0; i = pre[i], l--) {\n        seq[l] = i;\n    }\n\n    return seq;\n}\n\nfunction findGreatestIndexLEQ(seq, n) {\n    // invariant: lo is guaranteed to be index of a value <= n, hi to be >\n    // therefore, they actually start out of range: (-1, last + 1)\n    var lo = -1,\n        hi = seq.length;\n    \n    // fast path for simple increasing sequences\n    if (hi > 0 && seq[hi - 1] <= n) return hi - 1;\n\n    while (hi - lo > 1) {\n        var mid = Math.floor((lo + hi) / 2);\n        if (seq[mid] > n) {\n            hi = mid;\n        } else {\n            lo = mid;\n        }\n    }\n\n    return lo;\n}\n","\n// This is almost straightforward implementation of reconcillation algorithm\n// based on ivi documentation:\n// https://github.com/localvoid/ivi/blob/2c81ead934b9128e092cc2a5ef2d3cabc73cb5dd/packages/ivi/src/vdom/implementation.ts#L1366\n// With some fast paths from Surplus implementation:\n// https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L86\n//\n// How this implementation differs from others, is that it's working with data directly,\n// without maintaining nodes arrays, and uses dom props firstChild/lastChild/nextSibling\n// for markers moving.\nexport function reconcile(parent, renderedValues, data, createFn, noOp, beforeNode) {\n    // Fast path for clear\n    if (data.length === 0) {\n        parent.textContent = \"\"\n        return\n    }\n\n    // Fast path for create\n    if (renderedValues.length === 0) {\n        let node\n        for(let i = 0, len = data.length; i < len; i++) {\n            node = createFn(data[i])\n            parent.appendChild(node)\n        }\n        return\n    }\n\n    let prevStart = 0,\n        newStart = 0,\n        loop = true,\n        prevEnd = renderedValues.length-1, newEnd = data.length-1,\n        a, b,\n        prevStartNode = beforeNode ? beforeNode.nextSibling : parent.firstChild,\n        newStartNode = prevStartNode,\n        prevEndNode = parent.lastChild,\n        newEndNode = prevEndNode,\n        afterNode\n    \n    fixes: while(loop) {\n        loop = false\n        let _node\n\n        // Skip prefix\n        a = renderedValues[prevStart], b = data[newStart]\n        while(a === b) {\n            noOp(prevStartNode, b)\n            prevStart++\n            newStart++\n            newStartNode = prevStartNode = prevStartNode.nextSibling\n            if (prevEnd < prevStart || newEnd < newStart) break fixes\n            a = renderedValues[prevStart]\n            b = data[newStart]\n        }\n\n        // Skip suffix\n        a = renderedValues[prevEnd], b = data[newEnd]\n        while(a === b) {\n            noOp(prevEndNode, b)\n            prevEnd--\n            newEnd--\n            afterNode = prevEndNode\n            newEndNode = prevEndNode = prevEndNode.previousSibling\n            if (prevEnd < prevStart || newEnd < newStart) break fixes\n            a = renderedValues[prevEnd]\n            b = data[newEnd]\n        }\n\n        // Fast path to swap backward\n        a = renderedValues[prevEnd], b = data[newStart]\n        while(a === b) {\n            loop = true\n            noOp(prevEndNode, b)\n            _node = prevEndNode.previousSibling\n            parent.insertBefore(prevEndNode, newStartNode)\n            newEndNode = prevEndNode = _node\n            newStart++\n            prevEnd--\n            if (prevEnd < prevStart || newEnd < newStart) break fixes\n            a = renderedValues[prevEnd]\n            b = data[newStart]\n        }\n\n        // Fast path to swap forward\n        a = renderedValues[prevStart], b = data[newEnd]\n        while(a === b) {\n            loop = true\n            noOp(prevStartNode, b)\n            _node = prevStartNode.nextSibling\n            parent.insertBefore(prevStartNode, afterNode)\n            prevStart++\n            afterNode = newEndNode = prevStartNode\n            prevStartNode = _node\n            newEnd--\n            if (prevEnd < prevStart || newEnd < newStart) break fixes\n            a = renderedValues[prevStart]\n            b = data[newEnd]\n        }\n    }\n\n    // Fast path for shrink\n    if (newEnd < newStart) {\n        if (prevStart <= prevEnd) {\n            let next\n            while(prevStart <= prevEnd) {\n                if (prevEnd === 0) {\n                    parent.removeChild(prevEndNode)\n                } else {\n                    next = prevEndNode.previousSibling    \n                    parent.removeChild(prevEndNode)\n                    prevEndNode = next\n                }\n                prevEnd--\n            }\n        }\n        return\n    }\n\n    // Fast path for add\n    if (prevEnd < prevStart) {\n        if (newStart <= newEnd) {\n            let node, mode = afterNode ? 1 : 0\n            while(newStart <= newEnd) {\n                node = createFn(data[newStart])\n                mode ? parent.insertBefore(node, afterNode) : parent.appendChild(node)\n                newStart++\n            }\n        }\n        return\n    }\n\n    // Positions for reusing nodes from current DOM state\n    const P = new Array(newEnd + 1 - newStart)\n    for(let i = newStart; i <= newEnd; i++) P[i] = -1\n\n    // Index to resolve position from current to new\n    const I = new Map()\n    for(let i = newStart; i <= newEnd; i++) I.set(data[i], i)\n\n    let reusingNodes = 0, toRemove = []\n    for(let i = prevStart; i <= prevEnd; i++) {\n        if (I.has(renderedValues[i])) {\n            P[I.get(renderedValues[i])] = i\n            reusingNodes++\n        } else {\n            toRemove.push(i)\n        }\n    }\n\n    // Fast path for full replace\n    if (reusingNodes === 0) {\n        if (beforeNode) {\n            let node = beforeNode.nextSibling, tmp\n            while(prevStart <= prevEnd) {\n                tmp = node.nextSibling\n                parent.removeChild(node)\n                node = tmp\n                prevStart++\n            }\n        } else {\n            parent.textContent = \"\"\n        }\n        let node\n        for(let i = newStart; i <= newEnd; i++) {\n            node = createFn(data[i])\n            parent.appendChild(node)\n        }\n\n        return\n    }\n\n    // What else?\n    const longestSeq = longestPositiveIncreasingSubsequence(P, newStart)\n\n    // Collect nodes to work with them\n    const nodes = []\n    let tmpC = prevStartNode\n    for(let i = prevStart; i <= prevEnd; i++) {\n        nodes[i] = tmpC\n        tmpC = tmpC.nextSibling\n    }\n\n    for(let i = 0; i < toRemove.length; i++) parent.removeChild(nodes[toRemove[i]])\n\n    let lisIdx = longestSeq.length - 1, tmpD\n    for(let i = newEnd; i >= newStart; i--) {\n        if(longestSeq[lisIdx] === i) {\n            afterNode = nodes[P[longestSeq[lisIdx]]]\n            noOp(afterNode, data[i])\n            lisIdx--\n        } else {\n            if (P[i] === -1) {\n                tmpD = createFn(data[i])\n            } else {\n                tmpD = nodes[P[i]]\n                noOp(tmpD, data[i])\n            }\n            parent.insertBefore(tmpD, afterNode)\n            afterNode = tmpD\n        }\n    }\n}\n\nexport default reconcile\n\n// Picked from\n// https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L368\n\n// return an array of the indices of ns that comprise the longest increasing subsequence within ns\nfunction longestPositiveIncreasingSubsequence(ns, newStart) {\n    var seq = [],\n        is  = [],\n        l   = -1,\n        pre = new Array(ns.length);\n\n    for (var i = newStart, len = ns.length; i < len; i++) {\n        var n = ns[i];\n        if (n < 0) continue;\n        var j = findGreatestIndexLEQ(seq, n);\n        if (j !== -1) pre[i] = is[j];\n        if (j === l) {\n            l++;\n            seq[l] = n;\n            is[l]  = i;\n        } else if (n < seq[j + 1]) {\n            seq[j + 1] = n;\n            is[j + 1] = i;\n        }\n    }\n\n    for (i = is[l]; l >= 0; i = pre[i], l--) {\n        seq[l] = i;\n    }\n\n    return seq;\n}\n\nfunction findGreatestIndexLEQ(seq, n) {\n    // invariant: lo is guaranteed to be index of a value <= n, hi to be >\n    // therefore, they actually start out of range: (-1, last + 1)\n    var lo = -1,\n        hi = seq.length;\n    \n    // fast path for simple increasing sequences\n    if (hi > 0 && seq[hi - 1] <= n) return hi - 1;\n\n    while (hi - lo > 1) {\n        var mid = Math.floor((lo + hi) / 2);\n        if (seq[mid] > n) {\n            hi = mid;\n        } else {\n            lo = mid;\n        }\n    }\n\n    return lo;\n}\n","import {h,setupSyntheticEvent} from 'stage0'\nimport keyed from 'stage0/keyed'\nimport reconcile from 'stage0/reconcile'\n\nconst cellView = h`<td class=\"TableCell\">#text</td>`\nfunction TableCell(data) {\n    const root = cellView.cloneNode(true)\n    const refs = cellView.collect(root)\n\n    const {text} = refs\n\n    text.nodeValue = data\n\n    root.__click = () => console.log(\"Click\", data)\n\n    let a = data\n    root.update = function(data) {\n        if (data !== a) a = text.nodeValue = data\n    }\n\n    return root\n}\n\nconst rowView = h`<tr></tr>`\nfunction TableRow(item) {\n    const root = rowView.cloneNode(true)\n\n    root.dataset.id = item.id\n\n    const id = TableCell('#' + item.id)\n    root.appendChild(id)\n\n    let renderedProps = [],\n        a, a2\n    root.update = function(item) {\n        a2 = item.active ? 'TableRow active' : 'TableRow'\n\n        if (a2 !== a) a = root.className = a2\n\n        reconcile(\n            root,\n            renderedProps,\n            item.props,\n            item => TableCell(item),\n            (node, item) => node.update(item),\n            id\n        )\n        renderedProps = item.props.slice()\n    }\n    root.update(item)\n\n    return root\n}\n\nconst tableView = h`<table class=\"Table\"><tbody #tbody></tbody></table>`\nfunction Table(data) {\n    const root = tableView.cloneNode(true)\n    const refs = tableView.collect(root)\n\n    const {tbody} = refs\n\n    let renderedItems = []\n    root.update = function(data) {\n        keyed(\n            'id',\n            tbody,\n            renderedItems,\n            data.table.items,\n            item => TableRow(item),\n            (node, item) => node.update(item)\n        )\n        renderedItems = data.table.items.slice()\n    }\n    root.update(data)\n\n    return root\n}\n\nconst boxView = h`<div class=\"AnimBox\"></div>`\nfunction AnimBox(item) {\n    const root = boxView.cloneNode(true)\n\n    root.dataset.id = item.id\n\n    const style = root.style\n\n    let b, b2\n    root.update = function(item) {\n        b2 = item.time\n\n        if (b2 !== b) {\n            style.background = \"rgba(0,0,0,\" + (0.5 + ((b2 % 10) / 10)) + \")\"\n            style.borderRadius = (b2 % 10) + \"px\"\n            b = b2\n        }\n    }\n    root.update(item)\n\n    return root\n}\n\nconst animView = h`<div class=\"Anim\"></div>`\nfunction Anim(data) {\n    const root = animView.cloneNode(true)\n\n    let renderedItems = []\n    root.update = function(data) {\n        keyed(\n            'id',\n            root,\n            renderedItems,\n            data.anim.items,\n            item => AnimBox(item),\n            (node, item) => node.update(item)\n        )\n        renderedItems = data.anim.items.slice()\n    }\n    root.update(data)\n\n    return root\n}\n\nconst leafView = h`<li class=\"TreeLeaf\">#id</li>`\nfunction TreeLeaf(node) {\n    const root = leafView.cloneNode(true)\n    const refs = leafView.collect(root)\n\n    const {id} = refs\n\n    id.nodeValue = node.id\n\n    return root\n}\n\nconst nodeView = h`<ul class=\"TreeNode\"></ul>`\nfunction TreeNode(node) {\n    const root = nodeView.cloneNode(true)\n\n    let renderedItems = []\n    root.update = function(node) {\n        keyed(\n            'id',\n            root,\n            renderedItems,\n            node.children,\n            node => node.container ? TreeNode(node) : TreeLeaf(node),\n            (node, data) => node.update && node.update(data)\n        )\n        renderedItems = node.children.slice()\n    }\n    root.update(node)\n\n    return root\n}\n\nconst treeView = h`<div class=\"Tree\"></div>`\nfunction Tree(data) {\n    const root = treeView.cloneNode(true)\n\n    const node = TreeNode(data.tree.root)\n    root.appendChild(node)\n\n    root.update = function(data) {\n        node.update(data.tree.root)\n    }\n\n    return root\n}\n\nconst mainView = h`<div class=\"Main\">#section</div>`\nfunction Main() {\n    const root = mainView\n    const refs = mainView.collect(root)\n\n    let {section} = refs\n\n    function route(location, data) {\n        if (location === 'table') {\n          return Table(data)\n        } else if (location === 'anim') {\n          return Anim(data)\n        } else if (location === 'tree') {\n          return Tree(data)\n        }\n    }\n\n    let a = '', a2,\n        newSection\n    root.update = function(data) {\n        a2 = data.location\n\n        if (a2 !== a) {\n            newSection = route(a2, data)\n            root.replaceChild(newSection, section)\n            section = newSection\n            a = a2\n        } else {\n            section.update(data)    \n        }\n    }\n\n    return root\n}\n\nuibench.init(\"stage0\", \"0.0.2\")\n\ndocument.addEventListener(\"DOMContentLoaded\", e => {\n  setupSyntheticEvent('click')\n\n  const container = document.querySelector(\"#App\")\n  const app = Main()\n  container.appendChild(app)\n\n  uibench.run(\n    state => app.update(state),\n    samples => console.debug({samples})\n  )\n})"],"names":["nativeToSyntheticEvent","event","name","eventKey","dom","target","eventHandler","parentNode","CONFIGURED_SYNTHETIC_EVENTS","collector","node","nodeType","undefined","attributes","attr","aname","removeAttribute","slice","nodeData","nodeValue","compilerTemplate","document","createElement","h","strings","template","replace","innerHTML","content","firstChild","collect","tmp","prevPathId","pahtIdLen","code1","code2","ref","skip","pathId","nextSibling","length","lastIndexOf","Function","walker","keyed","key","parent","renderedValues","data","createFn","noOp","beforeNode","textContent","i","len","appendChild","a","b","afterNode","prevStart","newStart","loop","prevEnd","newEnd","prevStartNode","newStartNode","prevEndNode","lastChild","newEndNode","fixes","_node","previousSibling","insertBefore","next","removeChild","mode","P","Array","I","Map","set","reusingNodes","toRemove","has","get","push","longestSeq","ns","seq","is","l","pre","n","j","findGreatestIndexLEQ","longestPositiveIncreasingSubsequence","nodes","tmpC","tmpD","lisIdx","lo","hi","mid","Math","floor","reconcile","cellView","TableCell","root","cloneNode","refs","text","__click","console","log","update","rowView","tableView","Table","tbody","renderedItems","table","items","item","dataset","id","a2","renderedProps","active","className","props","TableRow","boxView","animView","Anim","anim","style","b2","time","background","borderRadius","AnimBox","leafView","nodeView","TreeNode","children","container","TreeLeaf","treeView","mainView","Main","section","route","location","tree","Tree","newSection","replaceChild","uibench","init","addEventListener","e","querySelector","app","run","state","samples","debug"],"mappings":"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"}