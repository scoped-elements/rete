(function () {
  'use strict';

  function collector(node) {
    if (node.nodeType !== 3) {
      if (node.attributes !== undefined) {
        for(let attr of node.attributes) {
          let aname = attr.name;
          if (aname[0] === '#') {
            node.removeAttribute(aname);
            return aname.slice(1)
          }
        }
      }
      return 0
    } else {
      let nodeData = node.nodeValue;
      if (nodeData[0] === '#') {
        node.nodeValue = "";
        return nodeData.slice(1)
      }
      return 0
    }
  }

  const ACTIONS = {
    FIRST_CHILD: 1,
    NEXT_SIBLING: 2,
    PARENT_NODE: 3,
    TAKE: 10
  };
  function walker2(node) {
    let skip = false, tmp, pathId = '', pahtIdLen, ref,
      paths = [], reflist = [], root = node;
    if (ref = collector(node)) paths.push(ACTIONS.TAKE);
    do {
        if (!skip && (tmp = node.firstChild)) {
            if (tmp.nodeType === 8) {
                tmp.parentNode.removeChild(tmp);
                continue
            }
            skip = false;       
            pathId += '_f';
            paths.push(ACTIONS.FIRST_CHILD);

            if (ref = collector(tmp)) {
              paths.push(ACTIONS.TAKE);
              reflist.push(ref);
            }
        } else if (tmp = node.nextSibling) {
            if (tmp.nodeType === 8) {
                tmp.parentNode.removeChild(tmp);
                continue
            }
            skip = false;
            pathId += '_n';
            paths.push(ACTIONS.NEXT_SIBLING);

            if (ref = collector(tmp)) {
              paths.push(ACTIONS.TAKE);
              reflist.push(ref);
            }
        } else {
            pahtIdLen = pathId.length;
            if (pathId[pahtIdLen - 1] === 'n') {
                pathId = pathId.slice(0, pathId.lastIndexOf('_f_n'));
            } else {
               pathId = pathId.slice(0, pahtIdLen- 2); 
               
            }
            paths.push(ACTIONS.PARENT_NODE);
            tmp = node.parentNode;
            skip = true;
        }
        node = tmp;
    } while (node && node !== root)
    return {paths, reflist}
  }

  function runtime(node) {
    const refs = {};
    const {paths, reflist} = this._refPaths;

    let tmp = node, refIdx = 0, path;
    for(let i = 0; i < paths.length; i++) {
      path = paths[i];
      if (path === ACTIONS.TAKE) {
        refs[reflist[refIdx++]] = tmp;
      } else if (path === ACTIONS.FIRST_CHILD) {
        tmp = tmp.firstChild;
      } else if (path === ACTIONS.NEXT_SIBLING) {
        tmp = tmp.nextSibling;
      } else if (path === ACTIONS.PARENT_NODE) {
        tmp = tmp.parentNode;
      }
    }

    return refs
  }

  const compilerTemplate = document.createElement('template');
  function h(strings, ...args) {
    let result = '';
    for(let i = 0; i < args.length; i++) result += strings[i] + args[i];
    result += strings[strings.length - 1];

    const template = result
      .replace(/>\n+/g, '>')
      .replace(/\s+</g, '<')
      .replace(/>\s+/g, '>')
      .replace(/\n\s+/g, '<!-- -->');
    compilerTemplate.innerHTML = template;
    const content = compilerTemplate.content.firstChild;
    content._refPaths = walker2(content);
    content.collect = runtime;
    return content
  }

  const nativeToSyntheticEvent = (event, name) => {
      const eventKey = `__${name}`;
      let dom = event.target;
      while(dom !== null) {
          const eventHandler = dom[eventKey];
          if (eventHandler) {
              eventHandler();
              return
          }
          dom = dom.parentNode;
      }
  };
  const CONFIGURED_SYNTHETIC_EVENTS = {};
  function setupSyntheticEvent(name) {
      if (CONFIGURED_SYNTHETIC_EVENTS[name]) return
      document.addEventListener(name, event => nativeToSyntheticEvent(event, name));
      CONFIGURED_SYNTHETIC_EVENTS[name] = true;
  }

  // This is almost straightforward implementation of reconcillation algorithm
  // based on ivi documentation:
  // https://github.com/localvoid/ivi/blob/2c81ead934b9128e092cc2a5ef2d3cabc73cb5dd/packages/ivi/src/vdom/implementation.ts#L1366
  // With some fast paths from Surplus implementation:
  // https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L86
  //
  // How this implementation differs from others, is that it's working with data directly,
  // without maintaining nodes arrays, and uses dom props firstChild/lastChild/nextSibling
  // for markers moving.
  function reconcile(parent, renderedValues, data, createFn, noOp, beforeNode, afterNode) {
      // Fast path for clear
      if (data.length === 0) {
          if (beforeNode !== undefined || afterNode !== undefined) {
              let node = beforeNode !== undefined ? beforeNode.nextSibling : parent.firstChild,
                  tmp;

              if (afterNode === undefined) afterNode = null;

              while(node !== afterNode) {
                  tmp = node.nextSibling;
                  parent.removeChild(node);
                  node = tmp;
              }
          } else {
              parent.textContent = "";    
          }
          return
      }

      // Fast path for create
      if (renderedValues.length === 0) {
          let node, mode = afterNode !== undefined ? 1 : 0;
          for(let i = 0, len = data.length; i < len; i++) {
              node = createFn(data[i]);
              mode ? parent.insertBefore(node, afterNode) : parent.appendChild(node);
          }
          return
      }

      let prevStart = 0,
          newStart = 0,
          loop = true,
          prevEnd = renderedValues.length-1, newEnd = data.length-1,
          a, b,
          prevStartNode = beforeNode ? beforeNode.nextSibling : parent.firstChild,
          newStartNode = prevStartNode,
          prevEndNode = afterNode ? afterNode.previousSibling : parent.lastChild,
          newEndNode = prevEndNode;
      
      fixes: while(loop) {
          loop = false;
          let _node;

          // Skip prefix
          a = renderedValues[prevStart], b = data[newStart];
          while(a === b) {
              noOp(prevStartNode, b);
              prevStart++;
              newStart++;
              newStartNode = prevStartNode = prevStartNode.nextSibling;
              if (prevEnd < prevStart || newEnd < newStart) break fixes
              a = renderedValues[prevStart];
              b = data[newStart];
          }

          // Skip suffix
          a = renderedValues[prevEnd], b = data[newEnd];
          while(a === b) {
              noOp(prevEndNode, b);
              prevEnd--;
              newEnd--;
              afterNode = prevEndNode;
              newEndNode = prevEndNode = prevEndNode.previousSibling;
              if (prevEnd < prevStart || newEnd < newStart) break fixes
              a = renderedValues[prevEnd];
              b = data[newEnd];
          }

          // Fast path to swap backward
          a = renderedValues[prevEnd], b = data[newStart];
          while(a === b) {
              loop = true;
              noOp(prevEndNode, b);
              _node = prevEndNode.previousSibling;
              parent.insertBefore(prevEndNode, newStartNode);
              newEndNode = prevEndNode = _node;
              newStart++;
              prevEnd--;
              if (prevEnd < prevStart || newEnd < newStart) break fixes
              a = renderedValues[prevEnd];
              b = data[newStart];
          }

          // Fast path to swap forward
          a = renderedValues[prevStart], b = data[newEnd];
          while(a === b) {
              loop = true;
              noOp(prevStartNode, b);
              _node = prevStartNode.nextSibling;
              parent.insertBefore(prevStartNode, afterNode);
              prevStart++;
              afterNode = newEndNode = prevStartNode;
              prevStartNode = _node;
              newEnd--;
              if (prevEnd < prevStart || newEnd < newStart) break fixes
              a = renderedValues[prevStart];
              b = data[newEnd];
          }
      }

      // Fast path for shrink
      if (newEnd < newStart) {
          if (prevStart <= prevEnd) {
              let next;
              while(prevStart <= prevEnd) {
                  if (prevEnd === 0) {
                      parent.removeChild(prevEndNode);
                  } else {
                      next = prevEndNode.previousSibling;    
                      parent.removeChild(prevEndNode);
                      prevEndNode = next;
                  }
                  prevEnd--;
              }
          }
          return
      }

      // Fast path for add
      if (prevEnd < prevStart) {
          if (newStart <= newEnd) {
              let node, mode = afterNode ? 1 : 0;
              while(newStart <= newEnd) {
                  node = createFn(data[newStart]);
                  mode ? parent.insertBefore(node, afterNode) : parent.appendChild(node);
                  newStart++;
              }
          }
          return
      }

      // Positions for reusing nodes from current DOM state
      const P = new Array(newEnd + 1 - newStart);
      for(let i = newStart; i <= newEnd; i++) P[i] = -1;

      // Index to resolve position from current to new
      const I = new Map();
      for(let i = newStart; i <= newEnd; i++) I.set(data[i], i);

      let reusingNodes = 0, toRemove = [];
      for(let i = prevStart; i <= prevEnd; i++) {
          if (I.has(renderedValues[i])) {
              P[I.get(renderedValues[i])] = i;
              reusingNodes++;
          } else {
              toRemove.push(i);
          }
      }

      // Fast path for full replace
      if (reusingNodes === 0) {
          if (beforeNode !== undefined || afterNode !== undefined) {
              let node = beforeNode !== undefined ? beforeNode.nextSibling : parent.firstChild,
                  tmp;

              if (afterNode === undefined) afterNode = null;

              while(node !== afterNode) {
                  tmp = node.nextSibling;
                  parent.removeChild(node);
                  node = tmp;
                  prevStart++;
              }
          } else {
              parent.textContent = "";
          }

          let node, mode = afterNode ? 1 : 0;
          for(let i = newStart; i <= newEnd; i++) {
              node = createFn(data[i]);
              mode ? parent.insertBefore(node, afterNode) : parent.appendChild(node);
          }

          return
      }

      // What else?
      const longestSeq = longestPositiveIncreasingSubsequence(P, newStart);

      // Collect nodes to work with them
      const nodes = [];
      let tmpC = prevStartNode;
      for(let i = prevStart; i <= prevEnd; i++) {
          nodes[i] = tmpC;
          tmpC = tmpC.nextSibling;
      }

      for(let i = 0; i < toRemove.length; i++) parent.removeChild(nodes[toRemove[i]]);

      let lisIdx = longestSeq.length - 1, tmpD;
      for(let i = newEnd; i >= newStart; i--) {
          if(longestSeq[lisIdx] === i) {
              afterNode = nodes[P[longestSeq[lisIdx]]];
              noOp(afterNode, data[i]);
              lisIdx--;
          } else {
              if (P[i] === -1) {
                  tmpD = createFn(data[i]);
              } else {
                  tmpD = nodes[P[i]];
                  noOp(tmpD, data[i]);
              }
              parent.insertBefore(tmpD, afterNode);
              afterNode = tmpD;
          }
      }
  }

  // Picked from
  // https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L368

  // return an array of the indices of ns that comprise the longest increasing subsequence within ns
  function longestPositiveIncreasingSubsequence(ns, newStart) {
      var seq = [],
          is  = [],
          l   = -1,
          pre = new Array(ns.length);

      for (var i = newStart, len = ns.length; i < len; i++) {
          var n = ns[i];
          if (n < 0) continue;
          var j = findGreatestIndexLEQ(seq, n);
          if (j !== -1) pre[i] = is[j];
          if (j === l) {
              l++;
              seq[l] = n;
              is[l]  = i;
          } else if (n < seq[j + 1]) {
              seq[j + 1] = n;
              is[j + 1] = i;
          }
      }

      for (i = is[l]; l >= 0; i = pre[i], l--) {
          seq[l] = i;
      }

      return seq;
  }

  function findGreatestIndexLEQ(seq, n) {
      // invariant: lo is guaranteed to be index of a value <= n, hi to be >
      // therefore, they actually start out of range: (-1, last + 1)
      var lo = -1,
          hi = seq.length;
      
      // fast path for simple increasing sequences
      if (hi > 0 && seq[hi - 1] <= n) return hi - 1;

      while (hi - lo > 1) {
          var mid = Math.floor((lo + hi) / 2);
          if (seq[mid] > n) {
              hi = mid;
          } else {
              lo = mid;
          }
      }

      return lo;
  }

  let did = 1;
  function buildData(count) {
    var adjectives = ["pretty", "large", "big", "small", "tall", "short", "long", "handsome", "plain", "quaint", "clean", "elegant", "easy", "angry", "crazy", "helpful", "mushy", "odd", "unsightly", "adorable", "important", "inexpensive", "cheap", "expensive", "fancy"];
    var colours = ["red", "yellow", "blue", "green", "pink", "brown", "purple", "brown", "white", "black", "orange"];
    var nouns = ["table", "chair", "house", "bbq", "desk", "car", "pony", "cookie", "sandwich", "burger", "pizza", "mouse", "keyboard"];
    var data = [];
    for (var i = 0; i < count; i++) {
      data.push({
        id: did++,
        label: adjectives[_random(adjectives.length)] + " " + colours[_random(colours.length)] + " " + nouns[_random(nouns.length)]
      });
    }
    return data;
  }
  function _random(max) {
    return Math.round(Math.random() * 1000) % max;
  }

  const itemView = h`<tr><td class="col-md-1">#id</td><td class="col-md-4"><a #select>#label</a></td><td class="col-md-1"><a #del><span class="glyphicon glyphicon-remove" aria-hidden="true"></span></a></td><td class="col-md-6"></td></tr>`;
  function Item(item, scope) {
    const root = itemView.cloneNode(true);
    const refs = itemView.collect(root);

    const { id, label, select, del } = refs;

    id.nodeValue = item.id;
    label.nodeValue = item.label;
    select.__click = () => scope.select(item);
    del.__click = () => scope.del(item);

    let a = '',
        a2,
        b = item.label,
        b2;
    root.update = function (selected) {
      a2 = item.id === selected ? 'danger' : '';
      b2 = item.label;

      if (a2 !== a) a = root.className = a2;
      if (b2 !== b) b = label.nodeValue = b2;
    };

    return root;
  }

  const mainView = h`<div class="container" id="main"><div class="jumbotron"><div class="row"><div class="col-md-6"><h1>stage0</h1></div><div class="col-md-6"><div class="row"><div class="col-sm-6 smallpad"><button type="button" class="btn btn-primary btn-block" id="run" #run>Create 1,000 rows</button></div><div class="col-sm-6 smallpad"><button type="button" class="btn btn-primary btn-block" id="runlots" #runlots>Create 10,000 rows</button></div><div class="col-sm-6 smallpad"><button type="button" class="btn btn-primary btn-block" id="add" #add>Append 1,000 rows</button></div><div class="col-sm-6 smallpad"><button type="button" class="btn btn-primary btn-block" id="update" #update>Update every 10th row</button></div><div class="col-sm-6 smallpad"><button type="button" class="btn btn-primary btn-block" id="clear" #cleardata>Clear</button></div><div class="col-sm-6 smallpad"><button type="button" class="btn btn-primary btn-block" id="swaprows" #swaprows>Swap Rows</button></div></div></div></div></div><table class="table table-hover table-striped test-data"><tbody #tbody></tbody></table><span class="preloadicon glyphicon glyphicon-remove" aria-hidden="true"></span></div>`;
  function Main() {
    setupSyntheticEvent('click');

    let root = mainView;
    let refs = mainView.collect(root);
    console.debug({ refs });

    let data = [],
        selected;

    const { tbody } = refs;

    refs.run.__click = () => {
      data = buildData(1000);
      update(0);
    };
    refs.runlots.__click = () => {
      data = buildData(10000);
      update(0);
    };
    refs.add.__click = () => {
      data = data.concat(buildData(1000));
      update(0);
    };
    refs.update.__click = () => {
      for (let i = 0; i < data.length; i += 10) {
        data[i].label += ' !!!';
      }
      update(1);
    };
    refs.cleardata.__click = () => {
      data = [];
      update(0);
    };
    refs.swaprows.__click = () => {
      if (data.length > 998) {
        var tmp = data[1];
        data[1] = data[998];
        data[998] = tmp;
      }
      update(0);
    };

    const scope = {
      select: item => {
        selected = parseInt(item.id);
        update(1);
      },
      del: item => {
        const id = item.id;
        const idx = data.findIndex(d => d.id === id);
        data.splice(idx, 1);
        update(0);
      }
    };

    let renderedData = [];
    function update(deep) {
      reconcile(tbody, renderedData, data, item => Item(item, scope), deep ? node => node.update(selected) : () => {});
      renderedData = data.slice();
    }

    return root;
  }

  const app = Main();
  document.getElementById('main').appendChild(app);

}());
//# sourceMappingURL=app.min.js.map
